<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêçVIBORITA COSMICAüöÄ</title>
    <meta property="og:image" content="https://i.postimg.cc/nhBJ2XQZ/viboritacosmica.jpg">
    <style>
        /* --- ESTILOS GENERALES --- */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #0b0c10;
            font-family: sans-serif; 
            color: #ecf0f1;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        
        /* Lienzo de Estrellas de Fondo (Toda la pantalla) */
        #bodyStarCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        /* --- NUEVO: Pantalla de Carga --- */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #0b0c10;
            color: #7fffd4;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            text-align: center;
            z-index: 100; /* Asegura que est√© por encima de todo */
        }
        #loading-spinner {
            border: 4px solid rgba(127, 255, 212, 0.2);
            border-top: 4px solid #7fffd4;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-top: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        h1 {
            color: #7fffd4; 
            margin-bottom: 20px;
            font-size: 2em;
            text-shadow: 3px 3px #1a5c4e;
            text-align: center;
            z-index: 10;
        }

        /* --- MEN√öS (ACTUALIZADO para incluir nuevos men√∫s) --- */
        #main-menu, #mode-select-menu, #difficulty-select-menu, #settings-menu, #how-to-play-menu, #about-menu {
            display: none; /* Inicialmente todos ocultos */
            flex-direction: column;
            align-items: center;
            padding: 30px;
            border: 5px solid #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.7);
            background-color: rgba(0, 0, 0, 0.7);
            min-width: 300px;
            z-index: 10;
            text-align: center;
        }
        
        /* Contenedores de Juego (Inicialmente Ocultos) */
        #game-container, #game-controls { 
            display: none; 
            z-index: 10;
        }

        /* Estilo de botones de Men√∫ */
        .menu-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            margin: 10px 0;
            border-radius: 5px;
            width: 100%;
            transition: background-color 0.3s ease;
            text-align: center;
            text-decoration: none; 
        }
        
        .menu-button.unavailable {
            background-color: #888;
            cursor: not-allowed;
            opacity: 0.7; 
        }

        .menu-button:hover {
            background-color: #2980b9;
        }
        
        /* Estilo espec√≠fico para botones de Redes Sociales */
        .menu-button.social-button {
            margin: 5px 0;
        }
        
        /* --- ESTILOS DEL JUEGO --- */
        #game-container {
            border: 5px solid #00ffff;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.7);
            position: relative;
            overflow: hidden;
            background-color: #000000;
        }

        /* starCanvas: Para el fondo de la LUNA est√°tico */
        #starCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0; 
        }
        
        /* gameCanvas: Para el fondo de la BASE (cambio aleatorio) y los elementos del juego */
        #gameCanvas {
            background-color: transparent;
            display: block;
            position: relative;
            z-index: 1;
        }

        /* Nuevo contenedor para Score y Pause */
        #game-controls {
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            width: 600px; 
            margin-top: 15px;
            margin-bottom: 5px;
            z-index: 10;
        }

        /* Bot√≥n de Pausa - Ahora fuera del canvas */
        #pauseButton {
            background-color: rgba(255, 255, 255, 0.4); 
            color: white;
            border: 2px solid #7fffd4; 
            padding: 8px 15px; 
            cursor: pointer;
            font-size: 1.1em; 
            border-radius: 5px;
            z-index: 5;
            box-shadow: 0 0 10px rgba(127, 255, 212, 0.5); 
        }
        
        #pauseButton:hover {
            background-color: rgba(255, 255, 255, 0.5);
        }

        /* Pantalla de Pausa/Game Over */
        #pause-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            text-align: center;
            display: none; 
            z-index: 2; 
        }
        
        #game-over-screen button, #pause-screen button {
            background-color: #00ff00;
            color: black;
            border: none;
            padding: 15px 30px;
            font-size: 0.8em;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 5px;
            transition: background-color 0.3s ease;
            font-family: sans-serif; 
        }

        #game-over-screen button:hover, #pause-screen button:hover {
            background-color: #00cc00;
        }
        
        /* --- MARCADOR --- */
        #score-board {
            font-size: 1.2em;
            color: #ecf0f1;
            text-align: left; 
            z-index: 10;
        }
        #score-board span {
            color: #f39c12;
            font-weight: bold;
        }

        .menu-content {
            padding-top: 10px;
            max-width: 300px;
            text-align: left;
            font-size: 0.9em;
        }

        .menu-content p, .menu-content ul {
            margin-top: 10px;
            margin-bottom: 15px;
        }
        
        /* Estilo para el r√©cord */
        #record-display {
             color: #ff4500; /* Color distintivo para el r√©cord */
             margin-left: 15px;
        }
    </style>
</head>
<body>
    <canvas id="bodyStarCanvas"></canvas> 
    
    <div id="loading-screen">
        <h1>Cargando Recursos C√≥smicos...</h1>
        <div id="loading-spinner"></div>
    </div>
    
    <h1>üêçVIBORITA COSMICAüöÄ</h1>

    <audio id="backgroundMusic" loop>
        <source src="https://archive.org/download/eric-skiff-underclocked-no-copyright-8-bit-music-background_202512/Eric%20Skiff%20-%20Underclocked%20%20NO%20COPYRIGHT%208-bit%20Music%20%20Background.mp3" type="audio/mp3">
        Tu navegador no soporta el elemento de audio.
    </audio>

    <div id="main-menu">
        <button id="mainPlayButton" class="menu-button">Jugar</button> 
        <button id="mainSettingsButton" class="menu-button">Ajustes</button>
        <button id="mainHowToPlayButton" class="menu-button">¬øC√≥mo se Juega?</button>
        <button id="mainAboutButton" class="menu-button">Acerca del Juego</button>
        </div>

    <div id="mode-select-menu">
        <h2>Selecciona Modo de Juego</h2>
        <button id="arcadeModeButton" class="menu-button">Arcade</button>
        <button class="menu-button unavailable">Modo Supervivencia: ¬°Pr√≥ximamente!</button>
        <button class="menu-button back-button" data-target="main-menu">‚Ü©Ô∏è Volver</button>
    </div>
    
    <div id="difficulty-select-menu">
        <h2>Selecciona Dificultad</h2>
        <div id="difficulty-buttons-container">
            </div>
        <button class="menu-button back-button" data-target="mode-select-menu">‚Ü©Ô∏è Volver</button>
    </div>

    <div id="settings-menu">
        <h2>Ajustes C√≥smicos</h2>
        <button id="toggleSoundButton" class="menu-button">Sonido: ON</button>
        <button id="toggleVibrationButton" class="menu-button">Vibraci√≥n: ON</button>
        <button class="menu-button back-button" data-target="main-menu">‚Ü©Ô∏è Volver</button>
    </div>

    <div id="how-to-play-menu">
        <h2>¬øC√≥mo se Juega?</h2>
        <div class="menu-content">
            <h3>Objetivo:</h3>
            <p>La v√≠borita se perdi√≥ en el espacio. ¬°Ay√∫dala a volver a casa! Pero cuidado, los aliens tratar√°n de impedirlo. Evita chocar con ellos y con tu propio cuerpo.</p>
            <h3>Mec√°nicas:</h3>
            <ul>
                <li>Manzana C√≥smica: Come la manzana C√≥smica para ganar puntos y hacer que la v√≠borita crezca.</li>
                <li>OVNI: Come el ovni especial que te teletransportar√° a un nuevo escenario.</li>
                <li>Aliens: Si chocas con un alien perder√°s. ¬°Son obst√°culos est√°ticos!</li>
                <li>Controles: Desliza el dedo o usa las flechas hacia la direcci√≥n deseada para mover a la v√≠borita.</li>
                <li>Pausa: Pulsa el bot√≥n de pausa o la tecla 'P' para pausar el juego.</li>
            </ul>
        </div>
        <button class="menu-button back-button" data-target="main-menu">‚Ü©Ô∏è Volver</button>
    </div>

    <div id="about-menu">
        <h2>Acerca del Juego</h2>
        <div class="menu-content">
            <p><strong>Creado por DX Games</strong></p>
            <p>Versi√≥n del juego: v1.0</p>
            
            <h3>¬°SIGUENOS!</h3>
            <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 10px;">
                <a href="https://www.facebook.com/profile.php?id=61584974510654" target="_blank" class="menu-button social-button" style="background-color: #3b5998;">Facebook</a>
                <a href="https://www.tiktok.com/@dxgamesofficial?_r=1&_t=ZS-923fS5rjZZv" target="_blank" class="menu-button social-button" style="background-color: #000000; border: 2px solid #fff;">TikTok</a>
            </div>
            <p style="margin-top: 15px;">¬°Gracias por jugar la versi√≥n final de esta aventura c√≥smica!</p>
        </div>
        <button class="menu-button back-button" data-target="main-menu">‚Ü©Ô∏è Volver</button>
    </div>

    <div id="game-controls">
        <div id="score-board">
            Puntuacion: <span id="current-score">0</span> | Nivel: <span id="current-level">1</span>
            <span id="record-display">| R√©cord: 0</span> </div>
        <button id="pauseButton">‚è∏Ô∏è Pausa</button> 
    </div>
    <div id="game-container">
        <canvas id="starCanvas" width="600" height="600"></canvas>
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        
        <div id="pause-screen">
            <h2>PAUSA C√ìSMICA</h2>
            <p>Presiona para reanudar o la tecla 'P'</p>
            <button id="resumeButton">Reanudar</button>
        </div>
        
        <div id="game-over-screen">
            <h2>¬°EXPLOSION COSMICA!</h2>
            <p>Dificultad: <span id="final-difficulty"></span></p>
            <p>Puntuacion Final: <span id="final-score">0</span></p>
            <p>Nivel Alcanzado: <span id="final-level">1</span></p>
            <button id="restartButton">Reiniciar Nave</button>
        </div>
    </div>
    
    <script>
        // Referencias del Canvas y Contexto
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas ? canvas.getContext('2d') : null;
        const starCanvas = document.getElementById('starCanvas'); 
        const starCtx = starCanvas ? starCanvas.getContext('2d') : null;
        const bodyStarCanvas = document.getElementById('bodyStarCanvas');
        const bodyStarCtx = bodyStarCanvas ? bodyStarCanvas.getContext('2d') : null;
        
        // Referencia de la M√∫sica
        const BACKGROUND_MUSIC = document.getElementById('backgroundMusic');

        // Referencias de Elementos de Juego
        const GAME_CONTAINER = document.getElementById('game-container');
        const GAME_CONTROLS = document.getElementById('game-controls'); 
        const SCORE_BOARD = document.getElementById('score-board');
        const SCORE_DISPLAY = document.getElementById('current-score');
        const LEVEL_DISPLAY = document.getElementById('current-level');
        const RECORD_DISPLAY = document.getElementById('record-display');
        const GAME_OVER_SCREEN = document.getElementById('game-over-screen');
        const FINAL_SCORE_DISPLAY = document.getElementById('final-score');
        const FINAL_LEVEL_DISPLAY = document.getElementById('final-level');
        const FINAL_DIFFICULTY_DISPLAY = document.getElementById('final-difficulty');
        const PAUSE_BUTTON = document.getElementById('pauseButton'); 
        const PAUSE_SCREEN = document.getElementById('pause-screen');
        const RESTART_BUTTON = document.getElementById('restartButton');
        const RESUME_BUTTON = document.getElementById('resumeButton');

        // Referencias de Men√∫s (ACTUALIZADO)
        const MAIN_MENU = document.getElementById('main-menu');
        const MODE_SELECT_MENU = document.getElementById('mode-select-menu'); // NUEVO
        const DIFFICULTY_SELECT_MENU = document.getElementById('difficulty-select-menu'); // NUEVO
        const DIFFICULTY_BUTTONS_CONTAINER = document.getElementById('difficulty-buttons-container'); // NUEVO
        
        const PLAY_BUTTON = document.getElementById('mainPlayButton');
        const ARCADE_MODE_BUTTON = document.getElementById('arcadeModeButton'); // NUEVO
        const SETTINGS_MENU = document.getElementById('settings-menu');
        const HOW_TO_PLAY_MENU = document.getElementById('how-to-play-menu');
        const ABOUT_MENU = document.getElementById('about-menu');
        
        const SETTINGS_BUTTON = document.getElementById('mainSettingsButton');
        const HOW_TO_PLAY_BUTTON = document.getElementById('mainHowToPlayButton');
        const ABOUT_BUTTON = document.getElementById('mainAboutButton');
        
        // ELIMINADO: const DIFFICULTY_SELECT_BUTTON = document.getElementById('difficultySelectButton');
        const TOGGLE_SOUND_BUTTON = document.getElementById('toggleSoundButton');
        const TOGGLE_VIBRATION_BUTTON = document.getElementById('toggleVibrationButton');
        
        // NUEVO: Referencia de la pantalla de carga
        const LOADING_SCREEN = document.getElementById('loading-screen'); 
        
        // Configuraci√≥n del Juego
        const CELL_SIZE = 20;
        const GRID_WIDTH = canvas ? canvas.width / CELL_SIZE : 30; 
        const GRID_HEIGHT = canvas ? canvas.height / CELL_SIZE : 30; 

        // Variables de Juego
        let snake, food, dx, dy, score, level, obstacles, gameLoopId, gameOver, gameSpeed, isPaused = false;
        let bodyStars = [];
        let bodyStarLoopId; 
        let highScore = 0; 

        // Variables de Touch/Swipe
        let touchStartX = 0;
        let touchStartY = 0;
        const MIN_SWIPE_DISTANCE = 30;
        
        // Variables de Efectos
        let floatOffset = 0; 
        
        // --- ESTADO DE AJUSTES ---
        let gameSettings = {
            sound: true, 
            vibration: true,
        };
        
        // --- FUNCI√ìN DE GESTI√ìN DE R√âCORDS (LOCALSTORAGE) ---
        function getRecordKey() {
            // CAMBIO: Generar una clave √∫nica para la dificultad actual
            return `cosmicSnakeHighScore_${currentDifficultyName}`;
        }
        
        function loadRecord() {
            // CAMBIO: Cargar el r√©cord espec√≠fico para la dificultad activa
            const savedRecord = localStorage.getItem(getRecordKey());
            return savedRecord ? parseInt(savedRecord) : 0;
        }

        function saveRecord(newScore) {
            const currentRecord = loadRecord();
            if (newScore > currentRecord) {
                // CAMBIO: Guardar usando la clave espec√≠fica de la dificultad
                localStorage.setItem(getRecordKey(), newScore);
                return true; 
            }
            return false;
        }
        
        // --- FUNCI√ìN DE VIBRACI√ìN Y SONIDO ---
        function triggerVibration(pattern = [50]) {
            if (gameSettings.vibration && navigator.vibrate) {
                navigator.vibrate(pattern);
            }
        }
        
        function playSound(type) {
            if (gameSettings.sound) {
                // Placeholder para l√≥gica de sonido (SFX)
            }
        }
        
        function playMusic() {
            if (gameSettings.sound && BACKGROUND_MUSIC) {
                BACKGROUND_MUSIC.volume = 0.5; 
                BACKGROUND_MUSIC.play().catch(e => console.log("Music play failed:", e)); 
            }
        }

        function pauseMusic() {
             if (BACKGROUND_MUSIC) {
                 BACKGROUND_MUSIC.pause();
             }
        }
        
        // --- GESTI√ìN DE SPRITES (URLs CORREGIDAS) ---
        const SNAKE_HEAD_IMAGE = new Image(); SNAKE_HEAD_IMAGE.src = 'https://i.postimg.cc/HLj35t9Z/V%C3%ADborita_cabeza.png';
        // CORREGIDO: Usar la URL del Cuerpo (segmento recto)
        const SNAKE_BODY_IMAGE = new Image(); SNAKE_BODY_IMAGE.src = 'https://i.postimg.cc/Bn0fP4n8/copilot-image-1765350583859.png';
        const SNAKE_TAIL_IMAGE = new Image(); SNAKE_TAIL_IMAGE.src = 'https://i.postimg.cc/dV54Lfrx/V%C3%ADborita_colita.png';
        // CORREGIDO: Usar la URL de la Curva/Giro
        const SNAKE_CURVE_IMAGE = new Image(); SNAKE_CURVE_IMAGE.src = 'https://i.postimg.cc/DwvxfhJK/Viborita_girar.png'; 
        const FOOD_IMAGE = new Image(); FOOD_IMAGE.src = 'https://i.postimg.cc/zf3pWkkq/Bolita_manzanacosmica.png';
        const SPECIAL_FOOD_IMAGE = new Image(); SPECIAL_FOOD_IMAGE.src = 'https://i.postimg.cc/3w61ZDL8/Bolita_ovni.png';
        const ALIEN_IMAGES = [];
        const ALIEN_GREEN_IMAGE = new Image(); ALIEN_GREEN_IMAGE.src = 'https://i.postimg.cc/BvypC1hx/Alien1.png';
        const ALIEN_RED_IMAGE = new Image(); ALIEN_RED_IMAGE.src = 'https://i.postimg.cc/yN5jTSfd/Alien2.png';
        const ALIEN_BLUE_IMAGE = new Image(); ALIEN_BLUE_IMAGE.src = 'https://i.postimg.cc/jj9chJ8Q/Alien3.png';
        ALIEN_IMAGES.push(ALIEN_GREEN_IMAGE, ALIEN_RED_IMAGE, ALIEN_BLUE_IMAGE);
        const STATIC_MOON_BG = new Image(); STATIC_MOON_BG.src = 'https://i.postimg.cc/PryxZTF5/moon-surface-with-earth.png'; 
        const BASE_IMAGES = [];
        const BASE_ALIEN = new Image(); BASE_ALIEN.src = 'https://i.postimg.cc/xC48PWNR/Base-alien.png';
        const BASE_LUNA = new Image(); BASE_LUNA.src = 'https://i.postimg.cc/x8VPwVVQ/Base_luna.png';
        const BASE_MARTE = new Image(); BASE_MARTE.src = 'https://i.postimg.cc/bJtTVNMm/Base_marte.png';
        const BASE_VOLCANICA = new Image(); BASE_VOLCANICA.src = 'https://i.postimg.cc/KctfnjtL/Base_volcanica.png';
        const BASE_ESPACIAL = new Image(); BASE_ESPACIAL.src = 'https://i.postimg.cc/3NQZsQQy/Base_espacial.png';
        const BASE_TIERRA = new Image(); BASE_TIERRA.src = 'https://i.postimg.cc/QCgqsYj0/Base_terrestre.png';
        BASE_IMAGES.push(BASE_ALIEN, BASE_LUNA, BASE_MARTE, BASE_VOLCANICA, BASE_ESPACIAL, BASE_TIERRA);
        let currentBaseImage = BASE_IMAGES[0];
        const ALL_IMAGES = [
            SNAKE_HEAD_IMAGE, SNAKE_BODY_IMAGE, SNAKE_TAIL_IMAGE, SNAKE_CURVE_IMAGE, 
            FOOD_IMAGE, SPECIAL_FOOD_IMAGE, 
            ALIEN_GREEN_IMAGE, ALIEN_RED_IMAGE, ALIEN_BLUE_IMAGE, 
            STATIC_MOON_BG,
            BASE_ALIEN, BASE_LUNA, BASE_MARTE, BASE_VOLCANICA, BASE_ESPACIAL, BASE_TIERRA 
        ];
        const totalImages = ALL_IMAGES.length;
        let loadedImages = 0;
        let spritesLoaded = false;

        function checkImagesLoaded() {
            loadedImages++;
            if (loadedImages === totalImages) {
                spritesLoaded = true;
                drawStaticBackground(); 
                // NUEVO: Ocultar la pantalla de carga y mostrar el men√∫ principal
                if (LOADING_SCREEN) LOADING_SCREEN.style.display = 'none';
                showMenu(MAIN_MENU); 
            }
        }
        
        ALL_IMAGES.forEach(img => {
            img.onload = checkImagesLoaded;
            img.onerror = () => { console.error(`Error al cargar la imagen: ${img.src}`); checkImagesLoaded(); };
            if (img.complete) { setTimeout(checkImagesLoaded, 0); }
        });
        
        // --- FIN GESTI√ìN DE SPRITES ---

        // --- CONFIGURACIONES DE DIFICULTAD ---
        const DIFFICULTIES_MAP = {
            // Ajuste F√°cil: initialSpeed a 300 (m√°s lento), baseChangeFrequency a 5 (m√°s seguido)
            "F√°cil": { name: "F√°cil", speedFactor: 1.0, foodToSpeedUp: 9999, foodToLevelUp: 5, initialSpeed: 300, maxObstacleFactor: 0.8, specialFoodFrequency: 5, allowPause: true, baseChangeFrequency: 5 },
            // Ajuste Normal: baseChangeFrequency a 10 (cada 10 bolitas)
            "Normal": { name: "Normal", speedFactor: 0.99, foodToSpeedUp: 10, foodToLevelUp: 5, initialSpeed: 200, maxObstacleFactor: 1.5, specialFoodFrequency: 10, allowPause: true, baseChangeFrequency: 10 },
            "Dif√≠cil": { name: "Dif√≠cil", speedFactor: 0.99, foodToSpeedUp: 3, foodToLevelUp: 5, initialSpeed: 150, maxObstacleFactor: 2.5, specialFoodFrequency: 10, allowPause: true, baseChangeFrequency: 10 } 
        };
        const DIFFICULTY_ORDER = ["F√°cil", "Normal", "Dif√≠cil"];
        let currentDifficultyName = "Normal";
        let currentDifficulty = DIFFICULTIES_MAP[currentDifficultyName]; 

        // --- Funciones de Men√∫ y Navegaci√≥n ---
        function showMenu(elementToShow) {
            // Ocultar todos los men√∫s y game elements (ACTUALIZADO)
            [MAIN_MENU, MODE_SELECT_MENU, DIFFICULTY_SELECT_MENU, SETTINGS_MENU, HOW_TO_PLAY_MENU, ABOUT_MENU, GAME_CONTAINER, GAME_OVER_SCREEN, PAUSE_SCREEN, GAME_CONTROLS].forEach(el => {
                if (el) el.style.display = 'none';
            });
            
            if (elementToShow) {
                elementToShow.style.display = 'flex';
                // Si mostramos el juego, tambi√©n mostramos los controles (Score y Pause)
                if (elementToShow === GAME_CONTAINER && GAME_CONTROLS) {
                    GAME_CONTROLS.style.display = 'flex';
                }
            }
        }

        // ELIMINADO: La funci√≥n setNextDifficulty ya no es necesaria.

        function startGame() {
            if (!spritesLoaded) {
                alert('Cargando recursos c√≥smicos... ¬°Espera un momento!');
                return;
            }
            
            playMusic();
            // CORRECCI√ìN: Pausar si el sonido est√° en OFF, ya que playMusic() se dispara siempre.
            if (!gameSettings.sound) {
                pauseMusic();
            }
            showMenu(GAME_CONTAINER);
            initGame();
        }

        function togglePause() {
            if (gameOver || !currentDifficulty.allowPause) return; 
            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(gameLoopId);
                pauseMusic(); 
                if (PAUSE_SCREEN) PAUSE_SCREEN.style.display = 'flex';
                if (PAUSE_BUTTON) PAUSE_BUTTON.textContent = '‚ñ∂Ô∏è Reanudar';
            } else {
                gameLoopId = setInterval(gameTick, gameSpeed);
                playMusic(); 
                if (PAUSE_SCREEN) PAUSE_SCREEN.style.display = 'none';
                if (PAUSE_BUTTON) PAUSE_BUTTON.textContent = '‚è∏Ô∏è Pausa';
            }
        }

        // --- Funciones de Fondo y Escenario ---
        function drawStaticBackground() {
            if (!starCtx || !starCanvas) return;
            starCtx.drawImage(STATIC_MOON_BG, 0, 0, starCanvas.width, starCanvas.height);
        }

        function changeBaseRandomly() {
            if (BASE_IMAGES.length > 0) {
                const randomIndex = Math.floor(Math.random() * BASE_IMAGES.length);
                currentBaseImage = BASE_IMAGES[randomIndex];
            }
        }
        
        function createStars(starArray, targetCanvas, count) {
            starArray.length = 0;
            if (!targetCanvas) return; 
            for (let i = 0; i < count; i++) {
                starArray.push({
                    x: Math.random() * targetCanvas.width,
                    y: Math.random() * targetCanvas.height,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 1.5 + 0.5 
                });
            }
        }
        
        function drawStars(starArray, targetCtx, targetCanvas) {
            if (!targetCtx || !targetCanvas) return;
            targetCtx.fillStyle = '#0b0c10'; 
            targetCtx.fillRect(0, 0, targetCanvas.width, targetCanvas.height);
            targetCtx.fillStyle = 'white'; 
            
            for (let i = 0; i < starArray.length; i++) {
                let star = starArray[i];
                star.x -= star.speed * 0.5; 
                star.y += star.speed * 0.2; 
                
                if (star.x < 0) star.x = targetCanvas.width;
                if (star.y > targetCanvas.height) star.y = 0;
                
                targetCtx.beginPath();
                targetCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                targetCtx.fill();
            }
        }

        function bodyStarLoop() {
            if (bodyStarCtx && bodyStarCanvas) {
                drawStars(bodyStars, bodyStarCtx, bodyStarCanvas);
            }
        }
        
        // --- Funciones de L√≥gica de Juego ---
        function updateScoreBoard() {
            if (SCORE_DISPLAY) SCORE_DISPLAY.textContent = score;
            if (LEVEL_DISPLAY) LEVEL_DISPLAY.textContent = level;
            // ACTUALIZACI√ìN: Mostrar el r√©cord cargado
            if (RECORD_DISPLAY) RECORD_DISPLAY.textContent = `| R√©cord: ${highScore}`;
        }

        function generateRandomPosition() {
            return {
                x: Math.floor(Math.random() * GRID_WIDTH),
                y: Math.floor(Math.random() * GRID_HEIGHT)
            };
        }

        function generateFood() {
            let newFoodPos;
            let isSpecial = (score > 0 && (score + 1) % currentDifficulty.specialFoodFrequency === 0);
            
            while (true) {
                newFoodPos = generateRandomPosition();
                let collisionWithSnake = snake.some(segment => segment.x === newFoodPos.x && segment.y === newFoodPos.y);
                let collisionWithObstacle = obstacles.some(obs => obs.x === newFoodPos.x && obs.y === newFoodPos.y);

                if (!collisionWithSnake && !collisionWithObstacle) {
                    food = { x: newFoodPos.x, y: newFoodPos.y, isSpecial: isSpecial };
                    break;
                }
            }
        }

        function regenerateObstacles() {
            obstacles = []; 
            const minObs = 5;
            const maxObs = Math.min(30, Math.floor(minObs * currentDifficulty.maxObstacleFactor + level * currentDifficulty.maxObstacleFactor));
            const numObstacles = Math.floor(Math.random() * (maxObs - minObs + 1)) + minObs;

            for (let k = 0; k < numObstacles; k++) {
                let newObsPos;
                while (true) {
                    newObsPos = generateRandomPosition();
                    let collisionWithSnake = snake.some(segment => segment.x === newObsPos.x && segment.y === newObsPos.y);
                    let collisionWithFood = (food && food.x === newObsPos.x && food.y === newObsPos.y);
                    let collisionWithExistingObstacle = obstacles.some(obs => obs.x === newObsPos.x && obs.y === newObsPos.y);
                    
                    // CORRECCI√ìN: Agregar zona de seguridad de 2 celdas alrededor de la cabeza
                    const head = snake[0];
                    const safeDistance = 2; 
                    const isNearHead = Math.abs(newObsPos.x - head.x) <= safeDistance && Math.abs(newObsPos.y - head.y) <= safeDistance;

                    if (!collisionWithSnake && !collisionWithFood && !collisionWithExistingObstacle && !isNearHead) {
                        obstacles.push({
                            x: newObsPos.x,
                            y: newObsPos.y,
                            type: Math.floor(Math.random() * ALIEN_IMAGES.length)
                        });
                        break;
                    }
                }
            }
        }
        
        /**
         * L√≥gica de aparici√≥n y cambio de Aliens basada en la dificultad.
         */
        function generateObstacles() {
            const d = currentDifficulty;
            if (d.name === "Dif√≠cil") {
                // Dif√≠cil: aparecen a la 1a bolita (score >= 1) y cambian de posici√≥n al comer una bolita (cada 1)
                if (score >= 1) { 
                    regenerateObstacles();
                }
            } else {
                // F√°cil/Normal: aparecen a la tercera bolita (score >= 3) y cambian de posici√≥n cada tres bolitas (score m√∫ltiplo de 3).
                if (score >= 3 && score % 3 === 0) {
                     regenerateObstacles();
                }
            }
        }
        
        function isCurve(i) {
            if (i === 0 || i === snake.length - 1) return false;
            const current = snake[i];
            const prev = snake[i - 1];
            const next = snake[i + 1];
            const isStraight = (prev.x === current.x && current.x === next.x) || (prev.y === current.y && current.y === next.y);
            return !isStraight;
        }
        
        function drawSegment(segment, index, isFood = false, isObstacle = false) {
            const x = segment.x * CELL_SIZE;
            const y = segment.y * CELL_SIZE;
            const size = CELL_SIZE;
            const radius = size / 2;
            const centerX = x + radius;
            const centerY = y + radius;
            
            if (!ctx) return;
            let scaleFactor = 1.5; 
            let drawSize = size * scaleFactor;

            if (spritesLoaded) {
                if (isFood) {
                    const SPECIAL_FOOD_SCALE = 1.2; 
                    const imageToUse = segment.isSpecial ? SPECIAL_FOOD_IMAGE : FOOD_IMAGE;
                    
                    if (segment.isSpecial) {
                         drawSize = size * SPECIAL_FOOD_SCALE; // Aplicar escala m√°s grande (1.2x)
                         // Dibujar centrado
                         ctx.drawImage(imageToUse, x - (drawSize - size) / 2, y - (drawSize - size) / 2, drawSize, drawSize);
                    } else {
                         ctx.drawImage(imageToUse, x, y, size, size); // Comida regular, tama√±o normal
                    }
                    return;
                }
                if (isObstacle) {
                    const alienImage = ALIEN_IMAGES[segment.type];
                    // Aplicar el offset de flotaci√≥n a la posici√≥n Y
                    ctx.drawImage(alienImage, x - (drawSize - size) / 2, y - (drawSize - size) / 2 + floatOffset, drawSize, drawSize);
                    return;
                }
                
                let imageToDraw;
                let rotation = 0;
                
                if (index === 0) {
                    imageToDraw = SNAKE_HEAD_IMAGE;
                    if (dx === 1) rotation = Math.PI / 2;
                    else if (dx === -1) rotation = -Math.PI / 2;
                    else if (dy === 1) rotation = Math.PI;
                    
                } else if (index === snake.length - 1) {
                    imageToDraw = SNAKE_TAIL_IMAGE;
                    const prevSegment = snake[index - 1];
                    const diffX = segment.x - prevSegment.x;
                    const diffY = segment.y - prevSegment.y;
                    if (diffX === 1) rotation = Math.PI / 2;
                    else if (diffX === -1) rotation = -Math.PI / 2;
                    else if (diffY === 1) rotation = Math.PI;
                    
                } else if (isCurve(index)) {
                    imageToDraw = SNAKE_CURVE_IMAGE;
                    const current = segment;
                    const prev = snake[index - 1];
                    const next = snake[index + 1];

                    if ((prev.x < current.x && next.y > current.y) || (prev.y < current.y && next.x > current.x)) rotation = 0;
                    else if ((prev.x < current.x && next.y < current.y) || (prev.y > current.y && next.x > current.x)) rotation = -Math.PI / 2;
                    else if ((prev.x > current.x && next.y > current.y) || (prev.y < current.y && next.x < current.x)) rotation = Math.PI;
                    else if ((prev.x > current.x && next.y < current.y) || (prev.y > current.y && next.x < current.x)) rotation = Math.PI / 2;

                } else {
                    imageToDraw = SNAKE_BODY_IMAGE;
                    const prevSegment = snake[index - 1];
                    const diffX = segment.x - prevSegment.x;
                    if (diffX !== 0) rotation = Math.PI / 2;
                }
                
                ctx.save();
                ctx.translate(centerX, centerY); 
                ctx.rotate(rotation);
                ctx.drawImage(imageToDraw, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                ctx.restore();
            }
        }

        function clearCanvas() {
            if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height); 
        }

        function drawGame() {
            clearCanvas();
            if (currentBaseImage && ctx) {
                ctx.drawImage(currentBaseImage, 0, 0, canvas.width, canvas.height);
            }
            // 1. Dibuja la comida
            drawSegment(food, -1, true, false); 
            // 2. Dibuja los obst√°culos
            obstacles.forEach(obs => drawSegment(obs, -2, false, true)); 
            // 3. Dibuja la v√≠bora (cabeza, cuerpo, cola)
            for (let i = 0; i < snake.length; i++) {
                drawSegment(snake[i], i, false, false);
            }
        }


        function checkCollision() {
            const head = snake[0];
            if (head.x < 0 || head.x >= GRID_WIDTH || head.y < 0 || head.y >= GRID_HEIGHT) return true;
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) return true;
            }
            for (let i = 0; i < obstacles.length; i++) {
                if (head.x === obstacles[i].x && head.y === obstacles[i].y) return true;
            }
            return false;
        }

        function initGame() {
            if (!canvas) return; 
            snake = [ { x: 10, y: 10 }, { x: 9, y: 10 }, { x: 8, y: 10 } ];
            dx = 1; dy = 0; 
            score = 0;
            level = 1;
            obstacles = []; 
            gameOver = false;
            isPaused = false;
            floatOffset = 0; 
            
            // Cargar el r√©cord al inicio (R√©cord espec√≠fico por dificultad)
            highScore = loadRecord();
            
            gameSpeed = currentDifficulty.initialSpeed;
            currentBaseImage = BASE_IMAGES[0];
            generateFood();
            
            updateScoreBoard();
            if (gameLoopId) clearInterval(gameLoopId);
            gameLoopId = setInterval(gameTick, gameSpeed);
            drawStaticBackground();
            if (GAME_OVER_SCREEN) GAME_OVER_SCREEN.style.display = 'none';
            if (PAUSE_BUTTON) PAUSE_BUTTON.textContent = '‚è∏Ô∏è Pausa';
        }


        function gameTick() {
            if (gameOver || isPaused) return;

            // Actualizar offset de flotaci√≥n (movimiento del alien)
            floatOffset = Math.sin(Date.now() / 200) * 3; 

            const head = { x: snake[0].x + dx, y: snake[0].y + dy };
            snake.unshift(head);

            if (checkCollision()) {
                gameOver = true;
                clearInterval(gameLoopId);
                pauseMusic(); 
                triggerVibration([200, 100, 200]);
                
                // Guardar r√©cord si es superado y recargar el valor
                saveRecord(score);
                highScore = loadRecord();
                
                if (GAME_OVER_SCREEN) GAME_OVER_SCREEN.style.display = 'flex';
                if (FINAL_SCORE_DISPLAY) FINAL_SCORE_DISPLAY.textContent = score;
                if (FINAL_LEVEL_DISPLAY) FINAL_LEVEL_DISPLAY.textContent = level;
                if (FINAL_DIFFICULTY_DISPLAY) FINAL_DIFFICULTY_DISPLAY.textContent = currentDifficulty.name;
                return;
            }
            
            const wasSpecial = food.isSpecial;

            if (head.x === food.x && head.y === food.y) {
                score++; 
                playSound('eat'); 
                triggerVibration(50);

                if (wasSpecial) { 
                    changeBaseRandomly(); 
                    regenerateObstacles(); 
                }
                
                // Usar la frecuencia de cambio de base definida en la dificultad
                const foodToChangeBase = currentDifficulty.baseChangeFrequency;
                if (score > 0 && score % foodToChangeBase === 0) {
                     changeBaseRandomly();
                }

                if (score > 0 && score % currentDifficulty.foodToSpeedUp === 0) { 
                    gameSpeed *= currentDifficulty.speedFactor; 
                    if (gameSpeed < 65) gameSpeed = 65; 
                    clearInterval(gameLoopId);
                    gameLoopId = setInterval(gameTick, gameSpeed);
                }
                
                if (score % currentDifficulty.foodToLevelUp === 0) { level++; }
                
                if (!wasSpecial) {
                   generateObstacles();
                }
                
                generateFood(); 
                updateScoreBoard();
            } else {
                snake.pop(); 
            }

            drawGame();
        }

        function changeDirection(new_dx, new_dy) {
            const goingUp = dy === -1;
            const goingDown = dy === 1;
            const goingLeft = dx === -1;
            const goingRight = dx === 1;

            if (new_dy === -1 && !goingDown) { dx = 0; dy = -1; } 
            else if (new_dy === 1 && !goingUp) { dx = 0; dy = 1; } 
            else if (new_dx === -1 && !goingRight) { dx = -1; dy = 0; } 
            else if (new_dx === 1 && !goingLeft) { dx = 1; dy = 0; }
        }
        
        // --- FUNCI√ìN NUEVA: Generar botones de dificultad para el modo Arcade ---
        function generateDifficultyButtons() {
            if (!DIFFICULTY_BUTTONS_CONTAINER) return;
            DIFFICULTY_BUTTONS_CONTAINER.innerHTML = ''; // Limpiar botones existentes

            DIFFICULTY_ORDER.forEach(diffName => {
                const button = document.createElement('button');
                button.className = 'menu-button';
                button.textContent = diffName;
                button.addEventListener('click', () => {
                    // 1. Establecer la dificultad
                    currentDifficultyName = diffName;
                    currentDifficulty = DIFFICULTIES_MAP[diffName];
                    // 2. Empezar el juego
                    startGame();
                });
                DIFFICULTY_BUTTONS_CONTAINER.appendChild(button);
            });
        }

        // --- Inicializaci√≥n y Event Listeners ---

        function setupMenuNavigation() {
            PLAY_BUTTON.addEventListener('click', () => { 
                showMenu(MODE_SELECT_MENU); // Ahora va al men√∫ de selecci√≥n de modo
            }); 
            
            if (ARCADE_MODE_BUTTON) {
                ARCADE_MODE_BUTTON.addEventListener('click', () => { 
                    generateDifficultyButtons();
                    showMenu(DIFFICULTY_SELECT_MENU); // Va al men√∫ de dificultad del modo Arcade
                });
            }
            
            SETTINGS_BUTTON.addEventListener('click', () => showMenu(SETTINGS_MENU));
            HOW_TO_PLAY_BUTTON.addEventListener('click', () => showMenu(HOW_TO_PLAY_MENU));
            ABOUT_BUTTON.addEventListener('click', () => showMenu(ABOUT_MENU));

            document.querySelectorAll('.back-button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const targetId = e.target.getAttribute('data-target');
                    showMenu(document.getElementById(targetId));
                });
            });
        }

        function setupSettings() {
            TOGGLE_SOUND_BUTTON.addEventListener('click', () => {
                gameSettings.sound = !gameSettings.sound;
                TOGGLE_SOUND_BUTTON.textContent = `Sonido: ${gameSettings.sound ? 'ON' : 'OFF'}`;
                
                if (gameSettings.sound) {
                    if (BACKGROUND_MUSIC.paused) {
                         playMusic(); 
                    }
                } else {
                    pauseMusic(); 
                }
            });

            TOGGLE_VIBRATION_BUTTON.addEventListener('click', () => {
                gameSettings.vibration = !gameSettings.vibration;
                TOGGLE_VIBRATION_BUTTON.textContent = `Vibraci√≥n: ${gameSettings.vibration ? 'ON' : 'OFF'}`;
                if (gameSettings.vibration) triggerVibration(50);
            });
            
            // ELIMINADO: La l√≥gica de selecci√≥n de dificultad ya no est√° aqu√≠.
        }
        
        // CONTROLES T√ÅCTILES 
        if (canvas) {
            canvas.addEventListener('touchstart', e => {
                if (GAME_CONTAINER.style.display === 'flex' && !isPaused) {
                    e.preventDefault(); 
                    const touch = e.touches[0];
                    touchStartX = touch.clientX;
                    touchStartY = touch.clientY;
                }
            });

            canvas.addEventListener('touchend', e => {
                if (GAME_CONTAINER.style.display === 'flex' && !isPaused && touchStartX !== 0) {
                    const touch = e.changedTouches[0];
                    const touchEndX = touch.clientX;
                    const touchEndY = touch.clientY;

                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchEndY - touchStartY;

                    if (Math.abs(deltaX) > MIN_SWIPE_DISTANCE || Math.abs(deltaY) > MIN_SWIPE_DISTANCE) {
                        if (Math.abs(deltaX) > Math.abs(deltaY)) {
                            if (deltaX > 0) { changeDirection(1, 0); } 
                            else { changeDirection(-1, 0); } 
                        } else { 
                            if (deltaY > 0) { changeDirection(0, 1); } 
                            else { changeDirection(0, -1); } 
                        }
                    }
                    touchStartX = 0;
                    touchStartY = 0;
                }
            });
        }
        
        // Controles de Teclado y Pausa/Reanudar/Reiniciar
        document.addEventListener('keydown', e => {
            if (GAME_CONTAINER && GAME_CONTAINER.style.display === 'flex') { 
                if (!isPaused) {
                    if (e.key === 'ArrowUp') { changeDirection(0, -1); } 
                    else if (e.key === 'ArrowDown') { changeDirection(0, 1); } 
                    else if (e.key === 'ArrowLeft') { changeDirection(-1, 0); } 
                    else if (e.key === 'ArrowRight') { changeDirection(1, 0); }
                }
                if (e.key === 'p' || e.key === 'P') { 
                    togglePause();
                }
            }
        });
        
        if (RESTART_BUTTON) RESTART_BUTTON.addEventListener('click', () => showMenu(MAIN_MENU));
        if (PAUSE_BUTTON) PAUSE_BUTTON.addEventListener('click', togglePause);
        if (RESUME_BUTTON) RESUME_BUTTON.addEventListener('click', togglePause);

        // --- Inicializaci√≥n de Fondo Estrellado del Body ---
        function initBodyStars() {
             if (bodyStarCanvas) {
                bodyStarCanvas.width = window.innerWidth;
                bodyStarCanvas.height = window.innerHeight;
                createStars(bodyStars, bodyStarCanvas, 300);
            }
        }
        
        function initApp() {
            initBodyStars();
            window.addEventListener('resize', initBodyStars);
            if (bodyStarLoopId) clearInterval(bodyStarLoopId);
            if (bodyStarCtx) {
                bodyStarLoopId = setInterval(bodyStarLoop, 30); 
            }

            setupMenuNavigation();
            setupSettings();
            
            // Cargar el r√©cord inicial para mostrarlo en el men√∫/pantalla
            highScore = loadRecord();
            
            // ELIMINADO: showMenu(MAIN_MENU); -- Ahora se muestra en checkImagesLoaded
        }

        initApp();
    </script>
</body>
</html>